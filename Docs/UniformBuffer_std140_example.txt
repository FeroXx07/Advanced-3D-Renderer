	/*LearnOpenGL example*/
	layout (std140) uniform ExampleBlock
	{
						 // base alignment  // base offset	// aligned offset	// bytes used
		float value;     // 4               // 0	 		// 0 				// 0..3
		vec3 vector;     // 16              // 4			// 16               // 16..31
		mat4 matrix;     // 16              // 32			// 32  (column 0)   // 32..47
						 // 16              // 48			// 48  (column 1)   // 48..63
						 // 16              // 64			// 64  (column 2)   // 64..79
						 // 16              // 80			// 80  (column 3)   // 80..95
		float values[3]; // 16              // 96			// 96  (values[0])  // 96..111
						 // 16              // 112			// 112 (values[1])  // 112..127
						 // 16              // 128			// 128 (values[2])  // 128..143
		bool boolean;    // 4               // 144			// 144              // 144..147
		int integer;     // 4               // 148			// 148              // 148..151
	}; 
	/*My example*/
	layout(std140) uniform TransformBlock
	{
								// base alignment	// base offset	// aligned offset
		float scale;			// 4				// 0			// 0			
		vec3 translation;		// 16				// 4			// 16	
		float rotation[3];		// 16				// 28			// 32
								// 16				// 48			// 48
								// 16				// 64			// 64
		mat4 projection_matrix; // 16				// 80			// 80
								// 16				// 96			// 96
								// 16				// 112			// 112
								// 16				// 128			// 128
	}
	
	Each block has to be aligned to GL_UNIFORM_BUFFER_OFFSET_ALIGNMENT that can be 16 bytes or 256 bytes depending on the GPU vendor.
	But each datatype base alignment stays the same for each type independently of the block alignment.

	/*OpenGL Khronos examples*/
	/*https://registry.khronos.org/OpenGL/extensions/ARB/ARB_uniform_buffer_object.txt*/
	By default, uniforms contained within a uniform block are extracted from
    buffer storage in an implementation-dependent manner. Applications may
    query the offsets assigned to uniforms inside uniform blocks with query
    functions provided by the GL.

    The "layout" qualifier provides shaders with control of the layout of
    uniforms within a uniform block. When the "std140" layout is specified,
    the offset of each uniform in a uniform block can be derived from the
    definition of the uniform block by applying the set of rules described
    below. 

    If a uniform block is declared in multiple shaders linked together into a
    single program, the link will fail unless the uniform block declaration,
    including layout qualifier, are identical in all such shaders.

    When using the "std140" storage layout, structures will be laid out in
    buffer storage with its members stored in monotonically increasing order
    based on their location in the declaration. A structure and each
    structure member have a base offset and a base alignment, from which an
    aligned offset is computed by rounding the base offset up to a multiple of
    the base alignment. The base offset of the first member of a structure is
    taken from the aligned offset of the structure itself. The base offset of
    all other structure members is derived by taking the offset of the last
    basic machine unit consumed by the previous member and adding one. Each
    structure member is stored in memory at its aligned offset. The members
    of a top-level uniform block are laid out in buffer storage by treating
    the uniform block as a structure with a base offset of zero.

      (1) If the member is a scalar consuming <N> basic machine units, the
          base alignment is <N>.

      (2) If the member is a two- or four-component vector with components
          consuming <N> basic machine units, the base alignment is 2<N> or
          4<N>, respectively.

      (3) If the member is a three-component vector with components consuming
          <N> basic machine units, the base alignment is 4<N>.

      (4) If the member is an array of scalars or vectors, the base alignment
          and array stride are set to match the base alignment of a single
          array element, according to rules (1), (2), and (3), and rounded up
          to the base alignment of a vec4. The array may have padding at the
          end; the base offset of the member following the array is rounded up
          to the next multiple of the base alignment.

      (5) If the member is a column-major matrix with <C> columns and <R>
          rows, the matrix is stored identically to an array of <C> column
          vectors with <R> components each, according to rule (4).

      (6) If the member is an array of <S> column-major matrices with <C>
          columns and <R> rows, the matrix is stored identically to a row of
          <S>*<C> column vectors with <R> components each, according to rule
          (4).

      (7) If the member is a row-major matrix with <C> columns and <R> rows,
          the matrix is stored identically to an array of <R> row vectors
          with <C> components each, according to rule (4).

      (8) If the member is an array of <S> row-major matrices with <C> columns
          and <R> rows, the matrix is stored identically to a row of <S>*<R>
          row vectors with <C> components each, according to rule (4).

      (9) If the member is a structure, the base alignment of the structure is
          <N>, where <N> is the largest base alignment value of any of its
          members, and rounded up to the base alignment of a vec4. The
          individual members of this sub-structure are then assigned offsets 
          by applying this set of rules recursively, where the base offset of
          the first member of the sub-structure is equal to the aligned offset
          of the structure. The structure may have padding at the end; the 
          base offset of the member following the sub-structure is rounded up
          to the next multiple of the base alignment of the structure.

      (10) If the member is an array of <S> structures, the <S> elements of
           the array are laid out in order, according to rule (9).

    For uniform blocks laid out according to these rules, the minimum buffer
    object size returned by the UNIFORM_BLOCK_DATA_SIZE query is derived by
    taking the offset of the last basic machine unit consumed by the last
    uniform of the uniform block (including any end-of-array or
    end-of-structure padding), adding one, and rounding up to the next
    multiple of the base alignment required for a vec4.

Examples

    The following example illustrates the rules specified by the "std140"
    layout.

      layout(std140) uniform Example {

                      // Base types below consume 4 basic machine units
                      //
                      //       base   base  align
                      // rule  align  off.  off.  bytes used
                      // ----  ------ ----  ----  -----------------------
        float a;      //  1       4     0    0    0..3
        vec2 b;       //  2       8     4    8    8..15
        vec3 c;       //  3      16    16   16    16..27
        struct {      //  9      16    28   32    (align begin)
          int d;      //  1       4    32   32    32..35
          bvec2 e;    //  2       8    36   40    40..47
        } f;          //  9      16    48   48    (pad end)
        float g;      //  1       4    48   48    48..51
        float h[2];   //  4      16    52   64    64..67 (h[0])
                      //                    80    80..83 (h[1])
                      //  4      16    84   96    (pad end of h)
        mat2x3 i;     // 5/4     16    96   96    96..107 (i, column 0)
                      //                   112    112..123 (i, column 1)
                      // 5/4     16   124  128    (pad end of i)
        struct {      //  10     16   128  128    (align begin)
          uvec3 j;    //  3      16   128  128    128..139 (o[0].j)
          vec2 k;     //  2       8   140  144    144..151 (o[0].k)
          float l[2]; //  4      16   152  160    160..163 (o[0].l[0])
                      //                   176    176..179 (o[0].l[1])
                      //  4      16   180  192    (pad end of o[0].l)
          vec2 m;     //  2       8   192  192    192..199 (o[0].m)
          mat3 n[2];  // 6/4     16   200  208    208..219 (o[0].n[0], column 0)
                      //                   224    224..235 (o[0].n[0], column 1)
                      //                   240    240..251 (o[0].n[0], column 2)
                      //                   256    256..267 (o[0].n[1], column 0)
                      //                   272    272..283 (o[0].n[1], column 1)
                      //                   288    288..299 (o[0].n[1], column 2)
                      // 6/4     16   300  304    (pad end of o[0].n)
                      //  9      16   304  304    (pad end of o[0])
                      //  3      16   304  304    304..315 (o[1].j)
                      //  2       8   316  320    320..327 (o[1].k)
                      //  4      16   328  336    336..347 (o[1].l[0])
                      //                   352    352..355 (o[1].l[1])
                      //  4      16   356  368    (pad end of o[1].l)
                      //  2       8   368  368    368..375 (o[1].m)
                      // 6/4     16   376  384    384..395 (o[1].n[0], column 0)
                      //                   400    400..411 (o[1].n[0], column 1)
                      //                   416    416..427 (o[1].n[0], column 2)
                      //                   432    432..443 (o[1].n[1], column 0)
                      //                   448    448..459 (o[1].n[1], column 1)
                      //                   464    464..475 (o[1].n[1], column 2)
                      // 6/4     16   476  480    (pad end of o[1].n)
                      //  9      16   480  480    (pad end of o[1])
        } o[2];
      };
